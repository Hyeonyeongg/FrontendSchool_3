<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <!-- 우아한 저하 -->
    <!-- 브라우저에 따라서 mp4까지 지원한다면 mp4를 지원하고, webm을 지원한다면 webm을 지원함. 만약, mp4, webm 혹은 비디오태그도 이해하지못하는 구식 브라우저라면? 비디오 요소가 아예 화면에 나오지 않음. 사용자에게 혼란을 줄 수 있음. 이때, 비디오 태그 안에 p태그 같은 것을 작성하여 설명을 해줄 수 있음. 비디오 태그의 기능 중 하나로 비디오소스와 관련없는 요소를 집어넣을 경우 비디오 로딩에 실패했을 때 관련 없는 요소를 내보내줌. 일종의 안전장치. 최악의 사용자 경험을 피하기 위한 테크닉. (비디오가 제대로 나올 때는 p태그가 아예 렌더링이 되지 않음. html의 예외처리) -->
    <video src="">
        <source src="test.mp4" type="video/mp4">
        <source src="test.webm" type="video/webm">
        <p>브라우저가 HTML5 비디오를 지원하지 않습니다. <a href="">비디오다운로드</a></p>
    </video>

    <script>
        //js에서 우아한 저하
        //canvas는 브라우저가 그림, 애니메이션, 요소의 이동 등을 표현할 수 있는 기능을 제공함. canvas는 화면에 렌더링할때 기본적으로 돔과 분리되어있음. 캔버스를 이용하지않고 애니메이션을 만들면 필연적으로 브라우저의 리플로우현상이 발생함. 요소를 움직이는 애니메이션을 구현할 경우 계속 리플로우 현상이 일어남. 리플로우가 발생하면 레이아웃, 페인트 트리를 다시 재계산하면서 다량의 연산작업이 필요한데, cnavas를 통해서 애니메이션이나 움직임을 구현하면 돔과 무관하기 때문에 리플로우나 리페인트현상이 전혀 일어나지않음. 고성능의 애니메이션이나 움직임을 표현하기 위해 canvas를 많이 사용함.
        const canvas = document.createElement("canvas");
        const warning = document.createElement('strong');

        const ctx = canvas.getContext("webgl"); //webgl은 2d그래픽을 표현하겠다. 브라우저에 그림을 그려줄 수 있는 여러가지 도구를 제공하는 context객체를 받아와서 ctx상수에 저장함.

        if(ctx) { 
            document.body.appendChild(canvas); //캔버스를 지원하는 브라우저라면 캔버스를 넣어줌.
        } else {
            warning.innerHTML = '이 사이트는 구형브라우저에서 사용되고 있습니다. 브라우저를 업그레이드 해주세요 제발 ㅠㅠ'
            document.body.appendChild(warning);
        }

    </script>
</body>
</html>